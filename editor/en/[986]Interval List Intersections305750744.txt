import heapq as h


def flattened_generator(arr, arr_id):
    for i, x in enumerate(arr):
        for j, y in enumerate(x):
            yield y, (j, arr_id)


def events(sorted_intervals_arrays):
    flattened_sorted_intervals_generators = [flattened_generator(x, i) for i, x in enumerate(sorted_intervals_arrays)]
    num_generators = len(flattened_sorted_intervals_generators)
    front = []
    for g in flattened_sorted_intervals_generators:
        try:
            x = next(g)
            front.append(x)
        except StopIteration:
            num_generators -= 1
    h.heapify(front)
    while len(front) > 0:
        y, (j,i) = h.heappop(front)
        yield y, (i, j)
        try:
            x = next(flattened_sorted_intervals_generators[i])
            h.heappush(front, x)
        except StopIteration:
            num_generators -= 1


class Solution:
    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        available_people = set()
        num_people = 2
        ret = []
        start = None
        for ts, (i, j) in events([A, B]):
            if j == 0:
                available_people.add(i)
                if len(available_people) == num_people:
                    start = ts
            else:
                if start is not None:
                    ret.append([start, ts])
                    start = None
                available_people.remove(i)
        return ret



# runtime:176 ms
# memory:13.3 MB
